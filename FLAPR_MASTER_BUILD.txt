================================================================================

  ███████╗██╗      █████╗ ██████╗ ██████╗  
  ██╔════╝██║     ██╔══██╗██╔══██╗██╔══██╗
  █████╗  ██║     ███████║██████╔╝██████╔╝
  ██╔══╝  ██║     ██╔══██║██╔═══╝ ██╔══██╗
  ██║     ███████╗██║  ██║██║     ██║  ██║
  ╚═╝     ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝

  The Auto-Plug Engine for Creators & Indie Hackers
  Schedule posts. Set a threshold. Watch your CTA fire itself.

  MASTER BUILD DOCUMENT — v1.0 FINAL
  Solo builder. Web only. Supabase-first. Agent-executable.

================================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  THE NAME: FLAPR
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

WHY FLAPR:
  "Flap" = wings spreading = content taking off = going viral
  When your post's wings flap and it takes off — your plug fires automatically.
  5 letters. 1 syllable. Zero ambiguity. You hear it once, you remember it.

COMPETITOR NAMES FOR CONTEXT (so you see the gap):
  Buffer, Hootsuite, Later, SocialPilot, Typefully, ContentStudio, SocialBee,
  Sendible, Viraly, RecurPost, Pallyy — ALL of these are generic schedulers.
  NOT ONE has auto-plugging. Flapr owns that word in the space.

DOMAIN / BRAND:
  Primary:    flapr.app   (clean, modern, SaaS-native TLD)
  Backup:     flapr.io    (still credible)
  Twitter/X:  @flaprapp   or @getflapr
  Tagline:    "Post it. Set it. Flapr does the rest."
  Alt:        "Your viral moment. Your CTA. Automatic."

WHAT FLAPR DOES IN ONE SENTENCE:
  Schedule posts to Twitter/X, LinkedIn, and Bluesky — then set a like threshold,
  and Flapr automatically replies with your product pitch the moment your post blows up.

VALIDATED BY: Founder used Typeful to schedule one post. It hit 100 likes.
Auto-plug fired. 3-4 sales of A20i Pro that day. Zero manual effort.
Flapr is that feature, productized, multi-platform, and built properly.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHAT WAS DECIDED ACROSS ALL PREVIOUS DOCUMENTS (DISTILLED)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

v1 (Executive Doc):  Named it OmniPlug. Good concept. Too broad a scope.
v2 (AI Blueprint):   Fastify + Railway + BullMQ + Redis + Prisma + NextAuth.
                     Way too complex for one person. ~45 packages. ~2,430 lines backend.
v3 (Supabase-First): Killed Fastify, Railway, Redis, Prisma, NextAuth entirely.
                     Replaced with Supabase Edge Functions + pg_cron + RLS.
                     ~19 packages. ~720 lines backend. $0/month to run.
Comparison Doc:      V3 wins on every axis for 0-100 users. Found 10 gaps:
                     no onboarding, no failure emails, no token refresh cron,
                     no rate limit protection, no server-side validation,
                     no retry logic, no usage enforcement, no post preview,
                     no plug analytics, Bluesky CID not stored separately.
Agent Plan:          All 10 gaps fixed. Added beta codes, test-users-first
                     phasing, full agent checklist. Removed mobile app entirely.
THIS DOCUMENT:       All of the above merged, cleaned, renamed to Flapr.
                     One document. One truth. Build from this only.

PLATFORMS IN SCOPE (V1 launch):
  Twitter/X   ✓   LinkedIn   ✓   Bluesky   ✓
  Instagram   ✗   (Meta App Review = 4-6 weeks. Add post-launch.)

NO MOBILE APP. NO DESKTOP APP. WEB ONLY. FOREVER.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  STACK (FINAL — NO DEBATES)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

FRONTEND (Next.js on Vercel):
  next@14.2          App Router, server components, zero-config Vercel deploy
  react@18.3         UI
  typescript@5.4     Strict mode everywhere
  tailwindcss@3.4    Styling
  shadcn/ui          Prebuilt accessible components (Button, Card, Dialog, etc.)
  @supabase/supabase-js@2.43   THE main client — auth + db + storage + fns
  @supabase/ssr@0.3            Next.js server-side Supabase client
  @tanstack/react-query@5      Server state, caching, background refetch
  zustand@4.5                  Lightweight global UI state
  @tiptap/react@2.4            Rich text post composer
  @tiptap/extension-character-count@2.4   Char limits per platform
  react-big-calendar@1.11      Drag-and-drop schedule calendar
  date-fns@3                   UTC date handling, relative times
  zod@3.23                     Form validation client-side
  react-hook-form@7.51         Form state management
  recharts@2.12                Analytics charts
  lucide-react@0.379           Icons
  @vercel/analytics@1          Page view tracking

BACKEND (Supabase Edge Functions — Deno runtime):
  NOTE: Edge Functions run on Deno (Supabase's runtime, not our choice).
        This only affects files in supabase/functions/**
        Next.js frontend is still Node.js as normal.
        Use npm: import prefix, fetch() not axios, Deno.env.get() not process.env

  npm:@supabase/supabase-js@2.43   DB + Admin client inside functions
  npm:twitter-api-v2@1.17         Twitter/X publish, reply, metrics
  npm:@atproto/api@0.12           Bluesky AT Protocol
  npm:stripe@15                   Billing webhooks
  npm:resend@3                    Transactional email
  fetch (Deno built-in)           LinkedIn + all other HTTP calls
  crypto (Deno built-in)          AES-256-GCM token encryption

INFRASTRUCTURE:
  Vercel (free)          Frontend hosting — auto-deploy on git push
  Supabase (free)        Postgres + Auth + Edge Functions + Storage + Cron + RLS
  Stripe                 Subscriptions (2.9% + 30¢ per transaction)
  Resend (free)          3,000 emails/month free
  Sentry (free)          Error tracking

MONTHLY COST AT MVP: $0
MONTHLY COST AT 100 USERS: $0
MONTHLY COST AT 1,000 USERS: ~$25 (Supabase Pro)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  FOLDER STRUCTURE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

flapr/
├── app/
│   ├── (auth)/
│   │   ├── login/page.tsx
│   │   └── register/page.tsx         ← Has beta code field
│   ├── (dashboard)/
│   │   ├── layout.tsx                ← Auth guard + sidebar
│   │   ├── dashboard/page.tsx        ← Stats + recent posts
│   │   ├── compose/page.tsx          ← Post composer
│   │   ├── schedule/page.tsx         ← Calendar view
│   │   ├── analytics/page.tsx        ← Engagement + plug stats
│   │   └── settings/page.tsx         ← Platforms + billing
│   ├── onboarding/page.tsx           ← 3-step wizard (new users only)
│   ├── auth/callback/route.ts        ← Supabase OAuth handler
│   ├── page.tsx                      ← Landing page (public)
│   └── layout.tsx
├── components/
│   ├── ui/                           ← shadcn components (auto-generated)
│   ├── PostComposer.tsx
│   ├── AutoPlugConfig.tsx
│   ├── PlatformConnector.tsx
│   ├── ScheduleCalendar.tsx
│   ├── PostPreview.tsx
│   └── UpgradeModal.tsx
├── lib/
│   ├── supabase/
│   │   ├── client.ts                 ← Browser client
│   │   ├── server.ts                 ← Server component client
│   │   └── database.types.ts         ← Auto-generated (npx supabase gen types)
│   └── constants.ts                  ← Platform limits, plan limits
├── middleware.ts                      ← Session refresh + route protection
├── supabase/
│   ├── config.toml
│   ├── migrations/
│   │   ├── 0001_schema.sql
│   │   ├── 0002_rls.sql
│   │   ├── 0003_storage.sql
│   │   ├── 0004_cron.sql
│   │   └── 0005_functions.sql        ← get_dashboard_stats() SQL function
│   └── functions/
│       ├── _shared/
│       │   ├── cors.ts
│       │   ├── supabase-admin.ts
│       │   ├── token-crypto.ts
│       │   ├── validators.ts
│       │   ├── usage.ts
│       │   ├── twitter.ts
│       │   ├── linkedin.ts
│       │   ├── bluesky.ts
│       │   ├── email-templates.ts
│       │   └── database.types.ts     ← Copy of lib/supabase/database.types.ts
│       ├── platform-connect/index.ts
│       ├── publish-post/index.ts
│       ├── poll-engagement/index.ts
│       ├── refresh-tokens/index.ts
│       ├── send-email/index.ts
│       ├── stripe-webhook/index.ts
│       ├── create-checkout-session/index.ts
│       └── create-portal-session/index.ts
├── package.json
└── .env.local

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  DATABASE SCHEMA (FINAL — POSTGRES / SUPABASE)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

FILE: supabase/migrations/0001_schema.sql

-- ENUMs
CREATE TYPE platform_type AS ENUM ('TWITTER', 'LINKEDIN', 'BLUESKY');
CREATE TYPE post_status   AS ENUM ('DRAFT','SCHEDULED','PUBLISHING','PUBLISHED','FAILED');
CREATE TYPE plug_status   AS ENUM ('PENDING','FIRED','FAILED','SKIPPED');
CREATE TYPE trigger_type  AS ENUM ('LIKES','COMMENTS','REPOSTS','TIME_AFTER_PUBLISH');
CREATE TYPE user_plan     AS ENUM ('FREE','PRO','AGENCY');

-- Users (extends Supabase auth.users — DO NOT create auth.users yourself)
CREATE TABLE public.users (
  id                     UUID        PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email                  TEXT        NOT NULL,
  name                   TEXT,
  avatar_url             TEXT,
  plan                   user_plan   NOT NULL DEFAULT 'FREE',
  onboarding_step        INTEGER     NOT NULL DEFAULT 0,
  stripe_customer_id     TEXT        UNIQUE,
  stripe_subscription_id TEXT        UNIQUE,
  is_beta_user           BOOLEAN     NOT NULL DEFAULT FALSE,
  created_at             TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at             TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Beta codes (controls who gets in during alpha/beta)
CREATE TABLE public.beta_codes (
  code       TEXT PRIMARY KEY,
  used_by    UUID REFERENCES public.users(id),
  used_at    TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Platform OAuth connections (tokens stored encrypted)
CREATE TABLE public.platform_connections (
  id               TEXT          PRIMARY KEY DEFAULT gen_random_uuid()::TEXT,
  user_id          UUID          NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  platform         platform_type NOT NULL,
  platform_user_id TEXT          NOT NULL,
  platform_handle  TEXT          NOT NULL,
  access_token     TEXT          NOT NULL,   -- AES-256-GCM encrypted
  refresh_token    TEXT,                     -- AES-256-GCM encrypted
  token_expires_at TIMESTAMPTZ,
  scopes           TEXT[]        NOT NULL DEFAULT '{}',
  is_active        BOOLEAN       NOT NULL DEFAULT TRUE,
  created_at       TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  updated_at       TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, platform)
);

-- Posts
CREATE TABLE public.posts (
  id            TEXT        PRIMARY KEY DEFAULT gen_random_uuid()::TEXT,
  user_id       UUID        NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  content       TEXT        NOT NULL,
  media_urls    TEXT[]      NOT NULL DEFAULT '{}',
  status        post_status NOT NULL DEFAULT 'DRAFT',
  scheduled_at  TIMESTAMPTZ,
  published_at  TIMESTAMPTZ,
  retry_count   INTEGER     NOT NULL DEFAULT 0,
  next_retry_at TIMESTAMPTZ,
  fail_reason   TEXT,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Per-platform targets for each post
CREATE TABLE public.post_targets (
  id                TEXT          PRIMARY KEY DEFAULT gen_random_uuid()::TEXT,
  post_id           TEXT          NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
  platform          platform_type NOT NULL,
  platform_post_id  TEXT,
  platform_post_url TEXT,
  bluesky_cid       TEXT,                    -- Bluesky-only: required for replies
  likes_count       INTEGER       NOT NULL DEFAULT 0,
  comments_count    INTEGER       NOT NULL DEFAULT 0,
  reposts_count     INTEGER       NOT NULL DEFAULT 0,
  last_polled_at    TIMESTAMPTZ,
  published_at      TIMESTAMPTZ,
  fail_reason       TEXT,
  UNIQUE(post_id, platform)
);

-- Auto-plug configurations (one per platform per post)
CREATE TABLE public.auto_plugs (
  id            TEXT          PRIMARY KEY DEFAULT gen_random_uuid()::TEXT,
  post_id       TEXT          NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
  platform      platform_type NOT NULL,
  plug_content  TEXT          NOT NULL,
  trigger_type  trigger_type  NOT NULL DEFAULT 'LIKES',
  trigger_value INTEGER       NOT NULL,
  status        plug_status   NOT NULL DEFAULT 'PENDING',
  fired_at      TIMESTAMPTZ,
  plug_post_id  TEXT,
  fail_reason   TEXT,
  created_at    TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  UNIQUE(post_id, platform)   -- prevents duplicate plugs at DB level
);

-- Rate limit tracking (prevents blowing Twitter API limits)
CREATE TABLE public.api_rate_tracking (
  user_id      UUID          NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  platform     platform_type NOT NULL,
  window_start TIMESTAMPTZ   NOT NULL,
  call_count   INTEGER       NOT NULL DEFAULT 0,
  PRIMARY KEY(user_id, platform, window_start)
);

-- Indexes
CREATE INDEX ON public.posts(user_id, status);
CREATE INDEX ON public.posts(scheduled_at) WHERE status = 'SCHEDULED';
CREATE INDEX ON public.posts(next_retry_at) WHERE status = 'FAILED' AND retry_count < 3;
CREATE INDEX ON public.post_targets(post_id);
CREATE INDEX ON public.auto_plugs(status) WHERE status = 'PENDING';
CREATE INDEX ON public.platform_connections(user_id, is_active);

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  RLS POLICIES + AUTH TRIGGER
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

FILE: supabase/migrations/0002_rls.sql

ALTER TABLE public.users               ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.beta_codes          ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.platform_connections ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.posts               ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.post_targets        ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.auto_plugs          ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.api_rate_tracking   ENABLE ROW LEVEL SECURITY;

-- Auto-create user profile when someone signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
  INSERT INTO public.users (id, email, name, avatar_url)
  VALUES (
    NEW.id, NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name'),
    NEW.raw_user_meta_data->>'avatar_url'
  ) ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END; $$;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- USERS
CREATE POLICY "own" ON public.users FOR ALL USING (auth.uid() = id);

-- BETA CODES (anyone can read to validate, only system can write)
CREATE POLICY "read" ON public.beta_codes FOR SELECT USING (TRUE);

-- PLATFORM CONNECTIONS
CREATE POLICY "own" ON public.platform_connections FOR ALL USING (auth.uid() = user_id);

-- POSTS
CREATE POLICY "own" ON public.posts FOR ALL USING (auth.uid() = user_id);

-- POST TARGETS (via parent post)
CREATE POLICY "own" ON public.post_targets FOR ALL USING (
  EXISTS (SELECT 1 FROM public.posts WHERE id = post_id AND user_id = auth.uid())
);

-- AUTO PLUGS (via parent post)
CREATE POLICY "own" ON public.auto_plugs FOR ALL USING (
  EXISTS (SELECT 1 FROM public.posts WHERE id = post_id AND user_id = auth.uid())
);

-- RATE TRACKING
CREATE POLICY "own" ON public.api_rate_tracking FOR ALL USING (auth.uid() = user_id);

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  SUPABASE AUTH CONFIGURATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

In Supabase Dashboard → Authentication → Providers:
  [✓] Email   (enable confirm email in production)
  [✓] X/Twitter
        Client ID:     TWITTER_CLIENT_ID
        Secret:        TWITTER_CLIENT_SECRET
        Callback URL:  https://[project-id].supabase.co/auth/v1/callback
  [✓] LinkedIn (OIDC) ← USE OIDC NOT the old LinkedIn
        Client ID:     LINKEDIN_CLIENT_ID
        Secret:        LINKEDIN_CLIENT_SECRET
        Callback URL:  https://[project-id].supabase.co/auth/v1/callback

In Authentication → URL Configuration:
  Site URL:      https://flapr.app
  Redirect URLs: https://flapr.app/auth/callback
                 http://localhost:3000/auth/callback

In supabase/config.toml (local dev):
  [auth]
  site_url = "http://localhost:3000"
  additional_redirect_urls = ["http://localhost:3000/auth/callback"]
  [auth.external.twitter]
  enabled = true
  client_id = "env(TWITTER_CLIENT_ID)"
  secret = "env(TWITTER_CLIENT_SECRET)"
  [auth.external.linkedin_oidc]
  enabled = true
  client_id = "env(LINKEDIN_CLIENT_ID)"
  secret = "env(LINKEDIN_CLIENT_SECRET)"

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ENVIRONMENT VARIABLES (EVERY SINGLE ONE)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# .env.local — NEVER commit. Add to Vercel dashboard for prod.

# Supabase (supabase.com → Project → Settings → API)
NEXT_PUBLIC_SUPABASE_URL=https://[id].supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ...
SUPABASE_SERVICE_ROLE_KEY=eyJ...        ← NEVER expose to browser

# Twitter/X (developer.twitter.com → App → Keys & Tokens)
TWITTER_CLIENT_ID=
TWITTER_CLIENT_SECRET=
TWITTER_BEARER_TOKEN=                   ← App-only: for read calls (saves user rate limits)

# LinkedIn OIDC (developer.linkedin.com → My Apps → Auth)
LINKEDIN_CLIENT_ID=
LINKEDIN_CLIENT_SECRET=

# Token encryption (generate: openssl rand -hex 32)
TOKEN_ENCRYPTION_KEY=                   ← AES-256 key for storing OAuth tokens in DB

# Stripe (dashboard.stripe.com → Developers → API Keys)
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_live_...
STRIPE_SECRET_KEY=sk_live_...
STRIPE_WEBHOOK_SECRET=whsec_...
STRIPE_PRO_PRICE_ID=price_...           ← Create in Stripe dashboard first
STRIPE_AGENCY_PRICE_ID=price_...

# Resend (resend.com → API Keys)
RESEND_API_KEY=re_...

# App
SITE_URL=https://flapr.app             ← http://localhost:3000 for local dev

# Set in Supabase Edge Function secrets (NOT in .env.local — separate):
# npx supabase secrets set KEY=value for each of the above EXCEPT NEXT_PUBLIC_* vars

# Optional
NEXT_PUBLIC_POSTHOG_KEY=phc_...
NEXT_PUBLIC_SENTRY_DSN=https://...

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  SUPABASE CLIENT SETUP (COPY EXACTLY)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

lib/supabase/client.ts (browser):
  import { createBrowserClient } from '@supabase/ssr'
  import type { Database } from './database.types'
  export const createClient = () =>
    createBrowserClient<Database>(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    )

lib/supabase/server.ts (server components + route handlers):
  import { createServerClient } from '@supabase/ssr'
  import { cookies } from 'next/headers'
  import type { Database } from './database.types'
  export const createClient = () => {
    const jar = cookies()
    return createServerClient<Database>(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      { cookies: {
          getAll: () => jar.getAll(),
          setAll: (s) => { try { s.forEach(({name,value,options}) => jar.set(name,value,options)) } catch {} }
      }}
    )
  }

middleware.ts (root):
  Refreshes sessions on every request. Redirects unauthenticated users away
  from /dashboard/* and /onboarding. Redirects logged-in users away from /login.
  Use @supabase/ssr createServerClient pattern (see v3 blueprint for full code).

app/auth/callback/route.ts:
  Exchanges OAuth code for session.
  On success: calls platform-connect Edge Function with provider_token.
  Redirects to /onboarding if onboarding_step < 3, else /dashboard.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  EDGE FUNCTIONS — COMPLETE MAP
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DENO RULES (mandatory — AI must follow these):
  ✓ import X from 'npm:package@version'   (NOT bare imports)
  ✓ Deno.env.get('VAR_NAME')              (NOT process.env)
  ✓ fetch() built-in                      (NOT axios, NOT node-fetch)
  ✓ crypto.subtle for AES-256-GCM         (NOT crypto-js, NOT Node crypto)
  ✓ TypeScript strict mode
  ✓ Every function returns Response with CORS headers
  ✓ Handle OPTIONS preflight in every function

────────────────────────────────────────────────────────────────────────────
  _shared/cors.ts
────────────────────────────────────────────────────────────────────────────
  export const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  }
  export const handleCors = (req: Request) =>
    req.method === 'OPTIONS' ? new Response('ok', { headers: corsHeaders }) : null
  export const json = (data: unknown, status = 200) =>
    new Response(JSON.stringify(data), { status, headers: {...corsHeaders,'Content-Type':'application/json'} })
  export const err = (msg: string, status = 400) => json({ error: msg }, status)

────────────────────────────────────────────────────────────────────────────
  _shared/supabase-admin.ts
────────────────────────────────────────────────────────────────────────────
  Creates admin Supabase client using SUPABASE_SERVICE_ROLE_KEY.
  Also exports getUserFromRequest(req) — verifies user JWT from Authorization header.
  Use admin client for all DB operations inside Edge Functions (bypasses RLS safely).

────────────────────────────────────────────────────────────────────────────
  _shared/token-crypto.ts
────────────────────────────────────────────────────────────────────────────
  AES-256-GCM using Deno's Web Crypto API (crypto.subtle).
  export async function encrypt(plaintext: string): Promise<string>
    — generates random 12-byte IV, encrypts, returns base64(iv + ciphertext)
  export async function decrypt(encrypted: string): Promise<string>
    — splits IV from ciphertext, decrypts, returns plaintext
  Key source: Deno.env.get('TOKEN_ENCRYPTION_KEY') (hex string)
  NEVER log decrypted values. NEVER return them to frontend.

────────────────────────────────────────────────────────────────────────────
  _shared/validators.ts
────────────────────────────────────────────────────────────────────────────
  Platform content limits:
    TWITTER: 280 chars
    LINKEDIN: 3000 chars
    BLUESKY: 300 chars
  validatePostContent(content, platform) → { valid: boolean, errors: string[] }
  Call at start of publish-post BEFORE any API calls.
  On fail: mark post FAILED with clear fail_reason. Do not retry.

────────────────────────────────────────────────────────────────────────────
  _shared/usage.ts
────────────────────────────────────────────────────────────────────────────
  Plan limits:
    FREE:   10 posts/mo, 5 plugs/mo
    PRO:    100 posts/mo, 50 plugs/mo
    AGENCY: unlimited
  checkAndEnforceLimit(userId, 'PUBLISH' | 'PLUG')
    — counts this calendar month's records, throws LIMIT_EXCEEDED if over
  checkRateLimit(userId, platform, max=45)
    — tracks API calls in 15-min windows in api_rate_tracking table
    — returns false if limit hit; caller delays post by 16 minutes

────────────────────────────────────────────────────────────────────────────
  _shared/twitter.ts
────────────────────────────────────────────────────────────────────────────
  import { TwitterApi } from 'npm:twitter-api-v2@1.17.0'
  class TwitterService:
    constructor(decryptedAccessToken: string)
    static fromEncrypted(encryptedToken) → TwitterService
    publishTweet(content) → { id, url }
    getTweetMetrics(tweetId) → { likes, reposts, comments }
      NOTE: Use TWITTER_BEARER_TOKEN (app-only) for reads, not user token
    replyToTweet(tweetId, content) → { id }
    static refreshTokens(encryptedRefresh) → { access_token, refresh_token, expires_in }

────────────────────────────────────────────────────────────────────────────
  _shared/linkedin.ts
────────────────────────────────────────────────────────────────────────────
  No SDK. Pure fetch(). Base: https://api.linkedin.com
  class LinkedInService:
    constructor(decryptedAccessToken: string)
    getMyUrn() → "urn:li:person:{id}"
    publishPost(content, authorUrn) → { id }
      POST /v2/ugcPosts with full body structure (see v3 blueprint section 8.2)
    getPostEngagement(postUrn) → { likes, comments }
    addComment(postUrn, content, authorUrn) → { id }
    static refreshToken(encryptedRefresh) → { access_token, refresh_token }

────────────────────────────────────────────────────────────────────────────
  _shared/bluesky.ts
────────────────────────────────────────────────────────────────────────────
  import { BskyAgent } from 'npm:@atproto/api@0.12.0'
  class BlueskyService:
    constructor(handle: string, decryptedAppPassword: string)
    static fromEncrypted(handle, encryptedPassword) → BlueskyService
    init() → MUST call before every operation (Deno does not persist sessions)
    publishPost(content) → { uri: string, cid: string }
      Store BOTH uri AND cid in post_targets (uri in platform_post_id, cid in bluesky_cid)
    getLikesCount(uri) → number
    replyToPost(uri, cid, content) → { uri }
      reply: { root: {uri,cid}, parent: {uri,cid} }

────────────────────────────────────────────────────────────────────────────
  _shared/email-templates.ts
────────────────────────────────────────────────────────────────────────────
  postFailed(platform, postPreview, reason, retryUrl) → { subject, html, text }
  plugFailed(platform, plugContent, reason) → { subject, html, text }
  tokenExpired(platform, reconnectUrl) → { subject, html, text }
  welcomeEmail(name) → { subject, html, text }
  All branded as Flapr. Keep plain and functional — no design debt for MVP.

────────────────────────────────────────────────────────────────────────────
  platform-connect/index.ts
────────────────────────────────────────────────────────────────────────────
  CALLED BY: auth/callback/route.ts (after Twitter/LinkedIn OAuth) + Settings UI (Bluesky)
  AUTH: user JWT required
  INPUT: { platform, access_token, refresh_token?, platform_user_id, platform_handle,
           expires_in?, scopes?, bluesky_handle?, bluesky_app_password? }
  LOGIC:
    1. Get user from JWT
    2. Encrypt access_token (and refresh_token if present)
    3. Upsert into platform_connections (conflict: user_id + platform)
    4. If user's onboarding_step < 1: update to 1
    5. Return { success, platform, handle }

────────────────────────────────────────────────────────────────────────────
  publish-post/index.ts
────────────────────────────────────────────────────────────────────────────
  CALLED BY:
    - Supabase Cron every minute (service role key) — batch mode
    - Frontend directly (user JWT) — single post immediate publish
  LOGIC (batch/cron mode):
    1. Query posts WHERE (status='SCHEDULED' AND scheduled_at <= NOW())
       OR (status='FAILED' AND retry_count < 3 AND next_retry_at <= NOW())
       LIMIT 20 per invocation (keeps under 150s timeout)
    2. For each post × each post_target:
       a. checkRateLimit(userId, platform) → if false, reschedule +16 min, skip
       b. validatePostContent(content, platform) → if invalid, mark FAILED, skip
       c. Check token_expires_at → refresh proactively if < 30 min left
       d. Decrypt access_token
       e. Call platform publish (TwitterService / LinkedInService / BlueskyService)
       f. SUCCESS: update post_targets (platform_post_id, published_at, etc.)
          If ALL targets published: update posts status=PUBLISHED
       g. TRANSIENT ERROR (5xx, 429): retry_count++, next_retry_at=+5min
       h. PERMANENT ERROR (4xx, content): status=FAILED, email user
  LOGIC (single post mode from frontend):
    Same but for one post_id from request body.

────────────────────────────────────────────────────────────────────────────
  poll-engagement/index.ts
────────────────────────────────────────────────────────────────────────────
  CALLED BY: Supabase Cron every 5 minutes (service role only)
  LOGIC:
    1. Query auto_plugs WHERE status='PENDING', joined with post_targets + platform_connections
       LIMIT 50 per invocation
    2. For each:
       a. Fetch live metrics from platform API
          Twitter: use TWITTER_BEARER_TOKEN for reads (app-only, 900 req/15min)
          LinkedIn: use user token to getPostEngagement()
          Bluesky: BlueskyService.getLikesCount(uri)
       b. Update post_targets.likes_count + last_polled_at
       c. Get metric matching trigger_type
       d. IF metric >= trigger_value AND status = 'PENDING':
          — Call platform reply API with plug_content
          — SUCCESS: update auto_plugs status=FIRED, fired_at, plug_post_id
            Also: auto-append UTM params to any URL in plug_content:
            ?utm_source=[platform]&utm_medium=autoplug&utm_campaign=flapr
          — FAIL: status=FAILED, fail_reason, email user
    3. Return { polled, fired, failed }
  DUPLICATE PREVENTION: UNIQUE(post_id, platform) on auto_plugs + status check = bulletproof

────────────────────────────────────────────────────────────────────────────
  refresh-tokens/index.ts
────────────────────────────────────────────────────────────────────────────
  CALLED BY: Supabase Cron daily at 2am UTC
  LOGIC:
    1. Query platform_connections WHERE token_expires_at < NOW() + INTERVAL '24h'
       AND is_active = TRUE AND platform != 'BLUESKY' (Bluesky doesn't expire)
    2. For each: call platform refresh API (TwitterService.refreshTokens / LinkedInService.refreshToken)
    3. Encrypt new tokens, update platform_connections
    4. If refresh FAILS: set is_active=FALSE, email user to reconnect

────────────────────────────────────────────────────────────────────────────
  send-email/index.ts
────────────────────────────────────────────────────────────────────────────
  Thin wrapper around Resend API.
  INPUT: { to, subject, html, text }
  POST to https://api.resend.com/emails using RESEND_API_KEY
  From: Flapr <noreply@flapr.app>

────────────────────────────────────────────────────────────────────────────
  stripe-webhook/index.ts
────────────────────────────────────────────────────────────────────────────
  Verifies Stripe signature. Handles:
    checkout.session.completed → update users.plan + stripe IDs
    customer.subscription.updated → update plan or downgrade to FREE
    customer.subscription.deleted → downgrade to FREE

────────────────────────────────────────────────────────────────────────────
  create-checkout-session/index.ts + create-portal-session/index.ts
────────────────────────────────────────────────────────────────────────────
  create-checkout: user JWT → Stripe checkout URL → return { url }
  create-portal:   user JWT → Stripe customer portal URL → return { url }
  Frontend does window.location.href = url in both cases.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  SUPABASE CRON JOBS (3 total)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

FILE: supabase/migrations/0004_cron.sql

CREATE EXTENSION IF NOT EXISTS pg_cron WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS pg_net  WITH SCHEMA extensions;

-- Store secrets in Vault first (run in SQL editor, not migration):
-- SELECT vault.create_secret('flapr_project_url', 'https://[ID].supabase.co');
-- SELECT vault.create_secret('flapr_service_key', '[SERVICE_ROLE_KEY]');

-- 1. Publish scheduled posts — every minute
SELECT cron.schedule('flapr-publish', '* * * * *',
  $$ SELECT net.http_post(
    url     := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name='flapr_project_url') || '/functions/v1/publish-post',
    headers := jsonb_build_object('Content-Type','application/json','Authorization','Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name='flapr_service_key')),
    body    := '{}'::jsonb) $$);

-- 2. Poll engagement + fire plugs — every 5 minutes
SELECT cron.schedule('flapr-poll', '*/5 * * * *',
  $$ SELECT net.http_post(
    url     := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name='flapr_project_url') || '/functions/v1/poll-engagement',
    headers := jsonb_build_object('Content-Type','application/json','Authorization','Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name='flapr_service_key')),
    body    := '{}'::jsonb) $$);

-- 3. Refresh expiring OAuth tokens — daily at 2am UTC
SELECT cron.schedule('flapr-refresh', '0 2 * * *',
  $$ SELECT net.http_post(
    url     := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name='flapr_project_url') || '/functions/v1/refresh-tokens',
    headers := jsonb_build_object('Content-Type','application/json','Authorization','Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name='flapr_service_key')),
    body    := '{}'::jsonb) $$);

VERIFY: SELECT jobname, schedule, active FROM cron.job;

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  FRONTEND PAGES — WHAT EACH ONE DOES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

app/page.tsx — LANDING PAGE (public)
  Hero: "Post it. Set it. Flapr does the rest."
  Subhero: "Schedule to Twitter, LinkedIn & Bluesky. Set a like threshold.
            Flapr auto-replies with your CTA the moment your post blows up."
  Visual: Animated mockup — post hits 100 likes → reply fires with CTA
  Social proof: "Got 4 sales from one scheduled post. Zero effort." — Founder
  Pricing: 3 cards (Free / Pro $19/mo / Agency $49/mo)
  CTA: "Get started free" → /register
  Keep it under 5 sections. No blog, no team, no about. Just convert.

app/(auth)/login/page.tsx
  2 OAuth buttons: "Continue with Twitter" + "Continue with LinkedIn"
  Email/password form below
  Link to /register

app/(auth)/register/page.tsx
  Same as login but sign up.
  BETA FIELD: "Enter invite code" — validates against beta_codes table
  Only users with valid code can register during alpha/beta.
  On email signup: supabase.auth.signUp({ email, password, options: { data: { full_name } } })
  Show "Check your email to confirm" on success.

app/onboarding/page.tsx — 3-STEP WIZARD
  Shown to every new user after signup. Blocked until step 3 complete.
  Progress bar: Step 1 of 3, Step 2 of 3, Step 3 of 3.
  Step 1 — Connect Platform:
    Twitter + LinkedIn OAuth buttons. Show "Connected ✓" if already linked.
    Next button enabled when ≥1 platform connected.
    On next: UPDATE users SET onboarding_step=1
  Step 2 — Write Your First Post:
    Simple textarea + platform selector + optional schedule time.
    INSERT into posts + post_targets on submit.
    UPDATE users SET onboarding_step=2
  Step 3 — Set Your First Auto-Plug:
    Pre-selects the post from Step 2.
    "When this post gets [___] likes, reply with:" textarea
    INSERT into auto_plugs on submit.
    UPDATE users SET onboarding_step=3
    router.push('/dashboard')

app/(dashboard)/layout.tsx — DASHBOARD SHELL
  Server component. Auth check. Redirect if onboarding incomplete.
  Sidebar: Dashboard | Compose | Schedule | Analytics | Settings
  Header: avatar, plan badge (FREE/PRO/AGENCY), notification bell
  Realtime banner: toast when post publishes or plug fires

app/(dashboard)/dashboard/page.tsx — HOME
  4 stat cards: Posts Scheduled | Plugs Fired (green if >0) | Published | Failed (red if >0)
  Recent posts table: last 10, with platform badges + status + plug status
  Click row → sheet drawer with per-platform detail
  Realtime: subscribe to posts changes, update stats live

app/(dashboard)/compose/page.tsx — COMPOSER
  Tiptap editor with CharacterCount extension
  Platform selector (only connected platforms shown)
  Per-platform char limit indicator (red when over)
  Media upload → Supabase Storage → image preview
  Schedule picker (UTC storage, local display)
  AutoPlugConfig per selected platform:
    trigger metric (Likes/Comments/Reposts) + value + plug message textarea
  Post Preview tab: styled mock of how post looks per platform
  Submit: INSERT post + targets + plugs → toast → /dashboard

app/(dashboard)/schedule/page.tsx — CALENDAR
  react-big-calendar, month view default
  Events colored by status: SCHEDULED=blue, PUBLISHED=green, FAILED=red, DRAFT=gray
  Click event → sheet with full detail + edit/delete

app/(dashboard)/analytics/page.tsx — ANALYTICS
  Time filter: 7d / 30d / 90d
  Posts over time: recharts LineChart, one line per platform
  Plugs performance table: which plug fired, what likes, when, UTM link
  Top posts by engagement: BarChart

app/(dashboard)/settings/page.tsx — SETTINGS
  Connected Platforms section:
    Twitter: [Connect OAuth] or [Connected @handle ✓] [Disconnect]
    LinkedIn: same
    Bluesky: inline form → handle + app password → platform-connect Edge Function
  Account section: name (editable), email (read-only), change password
  Plan & Billing:
    Current plan badge + usage bars (X/10 posts, X/5 plugs this month)
    FREE: "Upgrade to Pro $19/mo" button → create-checkout-session → Stripe
    PRO/AGENCY: "Manage Billing" → create-portal-session → Stripe portal

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  PLAN LIMITS (ENFORCED SERVER-SIDE IN EDGE FUNCTIONS)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

LIMIT                   FREE        PRO ($19/mo)    AGENCY ($49/mo)
──────────────────────  ──────────  ──────────────  ────────────────
Posts scheduled/month   10          100             Unlimited
Auto-plugs fired/month  5           50              Unlimited
Connected platforms     2           3               3
Media uploads/month     20          200             Unlimited
Analytics history       7 days      90 days         1 year
Post templates          3           25              Unlimited

On LIMIT_EXCEEDED: return 402 from Edge Function.
Frontend catches 402 → show UpgradeModal automatically.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  AGENT BUILD SEQUENCE (DO IN THIS ORDER — NO EXCEPTIONS)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

STEP 0 — AUDIT SCAFFOLD FIRST
  Run: find . -type f -name "*.ts" -o -name "*.tsx" | grep -v node_modules | sort
  Run: cat package.json
  Run: ls supabase/migrations/ 2>/dev/null
  Run: cat .env.local 2>/dev/null
  OUTPUT: List what exists, what's missing, what conflicts. Build only what's missing.

STEP 1 — DATABASE
  [ ] Create migrations 0001_schema.sql → apply with: npx supabase db push
  [ ] Create migrations 0002_rls.sql → apply
  [ ] Create migrations 0003_storage.sql → apply (creates post-media bucket)
  [ ] Create migrations 0005_functions.sql → apply (get_dashboard_stats SQL fn)
  [ ] Generate types: npx supabase gen types typescript --local > lib/supabase/database.types.ts
  [ ] Copy types: cp lib/supabase/database.types.ts supabase/functions/_shared/database.types.ts
  VERIFY: npx supabase db diff (should show no pending changes)

STEP 2 — AUTH + CLIENTS
  [ ] lib/supabase/client.ts
  [ ] lib/supabase/server.ts
  [ ] middleware.ts
  [ ] app/auth/callback/route.ts
  [ ] Configure Twitter + LinkedIn (OIDC) in Supabase Auth dashboard
  VERIFY: npx supabase start → visit http://localhost:3000/login → Twitter OAuth flow completes

STEP 3 — EDGE FUNCTION SHARED UTILITIES
  [ ] supabase/functions/_shared/cors.ts
  [ ] supabase/functions/_shared/supabase-admin.ts
  [ ] supabase/functions/_shared/token-crypto.ts
  [ ] supabase/functions/_shared/validators.ts
  [ ] supabase/functions/_shared/usage.ts
  [ ] supabase/functions/_shared/email-templates.ts
  [ ] supabase/functions/_shared/twitter.ts
  [ ] supabase/functions/_shared/linkedin.ts
  [ ] supabase/functions/_shared/bluesky.ts
  VERIFY: npx supabase functions serve (should start without errors)

STEP 4 — EDGE FUNCTIONS (CORE ENGINE — most important)
  [ ] platform-connect → deploy → test: npx supabase functions invoke platform-connect --no-verify-jwt
  [ ] send-email → deploy → test with real email
  [ ] publish-post → deploy → schedule a test post for 2 min from now, watch it publish
  [ ] poll-engagement → deploy → manually invoke, confirm it polls without errors
  [ ] refresh-tokens → deploy
  VERIFY: Full loop — schedule post → publish → like it → wait → plug fires

STEP 5 — CRON JOBS
  [ ] Apply migration 0004_cron.sql
  [ ] Set Vault secrets in Supabase SQL editor
  VERIFY: SELECT * FROM cron.job; — shows 3 active jobs
  VERIFY: Wait 5 min → SELECT * FROM cron.job_run_details ORDER BY start_time DESC LIMIT 10;

STEP 6 — BILLING FUNCTIONS
  [ ] stripe-webhook → deploy → add webhook endpoint in Stripe dashboard
  [ ] create-checkout-session → deploy
  [ ] create-portal-session → deploy
  VERIFY: Stripe test card 4242 4242 4242 4242 → plan updates in users table

STEP 7 — FRONTEND (in this order)
  [ ] Install all packages (see stack section)
  [ ] npx shadcn-ui@latest init + add required components
  [ ] app/(auth)/login/page.tsx
  [ ] app/(auth)/register/page.tsx (with beta code field)
  [ ] app/onboarding/page.tsx (3-step wizard)
  [ ] app/(dashboard)/layout.tsx (sidebar shell)
  [ ] app/(dashboard)/settings/page.tsx (platform connect — do this BEFORE compose)
  [ ] app/(dashboard)/compose/page.tsx (full composer with plug config)
  [ ] app/(dashboard)/dashboard/page.tsx (stats + recent posts)
  [ ] app/(dashboard)/schedule/page.tsx (calendar)
  [ ] app/(dashboard)/analytics/page.tsx (charts)
  [ ] app/page.tsx (landing page — do LAST)

STEP 8 — DEPLOYMENT
  [ ] npx supabase link --project-ref [ID]
  [ ] npx supabase secrets set TOKEN_ENCRYPTION_KEY=... TWITTER_CLIENT_ID=... (all secrets)
  [ ] npx supabase functions deploy (deploys all functions)
  [ ] Push to GitHub → Vercel auto-deploys
  [ ] Add all env vars in Vercel dashboard
  [ ] Update Auth URLs in Supabase + Twitter + LinkedIn developer portals
  [ ] Add Stripe webhook endpoint

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ALPHA → BETA → PUBLIC (TEST-USERS-FIRST)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ALPHA (YOU ONLY — Week 1-3):
  1. Run the 5-point full loop test yourself before anyone else touches it:
     [ ] Sign up with beta code → /onboarding appears
     [ ] Connect Twitter account → platform_connections row in DB
     [ ] Write post → schedule 2 min from now → set plug at 1 like
     [ ] Wait 2 min → posts.status = PUBLISHED
     [ ] Check Twitter → tweet exists
     [ ] Like your own tweet → wait 5 min
     [ ] Check auto_plugs.status = FIRED
     [ ] Check Twitter → reply exists under tweet
  2. Test failure: disconnect Twitter, schedule post, watch failure email arrive
  3. Test billing: upgrade to Pro with test card, verify users.plan = PRO
  All 3 must pass before beta invites go out.

BETA (10-20 PEOPLE — Week 4-5):
  1. Insert 20 beta codes: INSERT INTO beta_codes (code) VALUES ('FLAPR-XXX'), ...
  2. Invite personally — creators, indie hackers you know
  3. Watch every day:
     SELECT * FROM cron.job_run_details ORDER BY start_time DESC LIMIT 20;
     SELECT * FROM posts WHERE status = 'FAILED' ORDER BY created_at DESC;
     SELECT * FROM auto_plugs WHERE status = 'FAILED';
  4. Talk to every beta user after 48 hours. Ask:
     "Did a plug fire for you? What happened after?"
     "What was confusing about setting up the auto-plug?"
     "Would you pay $19/mo for this?"

PUBLIC (Week 6-10 — 100 user target):
  Build before opening sign-ups:
  [ ] Auto-repost feature (repost own post after N hours — in poll-engagement)
  [ ] Post templates (3 free, unlimited Pro)
  [ ] Bluesky connect UI in Settings
  [ ] Landing page live (app/page.tsx)
  Remove beta code requirement from register page.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  DISTRIBUTION PLAN (HOW TO GET 100 USERS)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. USE FLAPR TO PLUG FLAPR
   Schedule 3 posts/week about Flapr on your Twitter + LinkedIn.
   Set auto-plugs at 50 likes: "Built this because I got 4 sales from 1 scheduled
   post. Try Flapr free → flapr.app"
   This is the product demoing itself. Most powerful distribution possible.

2. INDIE HACKERS (Week 6)
   Post: "Show IH: Built a tool that auto-replies with your CTA when posts go viral"
   Share the founder story — A20i Pro, 4 sales, 1 post, zero effort.
   Real story. Real numbers. Indie Hackers eats this up.

3. TWITTER/X CREATOR COMMUNITIES (Week 7)
   Target people complaining about Buffer/Hootsuite missing features.
   Reply to "what social tools do you use" threads.
   Single message: "None of them auto-plug. Built one that does. Flapr."

4. REDDIT (Week 8)
   r/SaaS, r/Entrepreneur, r/Indiegaming if relevant, r/justlearnedtocode
   Same raw honest story. Show the before/after (manual plugging vs Flapr).

5. PRODUCT HUNT (Week 10)
   Launch on a Tuesday or Wednesday.
   Goal: top 5 of the day → hundreds of sign-ups in 24 hours.
   Prep: get 50 beta users to upvote. Tagline: "Auto-plug when your posts go viral"

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  SUCCESS METRICS (100-USER MVP)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

METRIC                    TARGET        HOW TO CHECK
────────────────────────  ────────────  ──────────────────────────────────────
Sign-ups                  200           SELECT COUNT(*) FROM auth.users;
Weekly active users       100           PostHog weekly active events
Posts scheduled           500           SELECT COUNT(*) FROM posts;
Auto-plugs fired          150           SELECT COUNT(*) FROM auto_plugs WHERE status='FIRED';
Paying users              10            Stripe dashboard
MRR                       $190+         10 × $19 Pro
Post failure rate         < 5%          FAILED / (FAILED + PUBLISHED)
Onboarding completion     > 60%         SELECT COUNT(*) FROM users WHERE onboarding_step=3;
Plug-to-sales mentions    3+            Search "flapr" on Twitter

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHAT IS NOT BEING BUILT (DO NOT BUILD THESE)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

NO MOBILE APP             Web only. Full stop.
NO DESKTOP APP            Web only. Full stop.
NO INSTAGRAM (MVP)        Meta App Review = 4-6 weeks. Add post-launch.
NO AI POST GENERATOR      Not core. Add after revenue if users ask.
NO TEAM WORKSPACES        Premature. No team uses unvalidated products.
NO A/B PLUG TESTING       Complex. Build after 100 users give feedback.
NO MULTI-ACCOUNT          Too complex. Add when agencies buy Agency plan.
NO BROWSER EXTENSION      Scope creep. Web app is the product.
NO ADVANCED ANALYTICS     Recharts is enough. Build when users ask for more.
NO BULK CSV IMPORT        Power user feature. Add after PMF.
NO WHITE LABEL            Enterprise feature. Add after Agency plan sells.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  PACKAGE.JSON SCRIPTS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

"scripts": {
  "dev":        "next dev",
  "build":      "next build",
  "start":      "next start",
  "lint":       "next lint",
  "typecheck":  "tsc --noEmit",
  "gen:types":  "supabase gen types typescript --local > lib/supabase/database.types.ts && cp lib/supabase/database.types.ts supabase/functions/_shared/database.types.ts",
  "db:push":    "supabase db push",
  "db:reset":   "supabase db reset",
  "fn:serve":   "supabase functions serve",
  "fn:deploy":  "supabase functions deploy",
  "fn:invoke":  "supabase functions invoke"
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  UNIVERSAL AI PROMPT FOR YOUR AGENT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Paste this at the start of EVERY coding session with your agent:

  ───────────────────────────────────────────────────────────────────
  You are building Flapr — a social media auto-plug engine.

  STACK:
    Frontend: Next.js 14 App Router + Tailwind + shadcn/ui
    Database: Supabase (Postgres) — types in lib/supabase/database.types.ts
    Auth: Supabase Auth (no NextAuth, no custom JWT)
    Backend: Supabase Edge Functions ONLY (no Fastify, no Express)
    Edge Runtime: DENO — use npm: imports, fetch(), Deno.env.get(), crypto.subtle
    Storage: Supabase Storage (bucket: post-media)
    Billing: Stripe via Edge Functions
    Email: Resend via Edge Functions

  RULES:
    - No mobile app. No desktop app. Web only.
    - No axios. No node-fetch. Use fetch() in Edge Functions.
    - No process.env in Edge Functions. Use Deno.env.get('KEY').
    - No Prisma. No custom ORM. Use supabase-js client.
    - No NextAuth. Auth is Supabase Auth.
    - TypeScript strict mode everywhere. No 'any' types.
    - Every Edge Function must handle CORS and OPTIONS preflight.
    - Never log or expose decrypted OAuth tokens.
    - Platforms: TWITTER, LINKEDIN, BLUESKY only. No Instagram.

  [PASTE RELEVANT SECTION FROM THIS DOCUMENT]

  Task: [SPECIFIC THING TO BUILD]
  ───────────────────────────────────────────────────────────────────

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  10-WEEK TIMELINE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Week 1-2   DB + Auth + Clients + platform-connect     You can connect platforms
Week 3     publish-post + poll-engagement + crons     Full auto-plug loop works
Week 4     Composer UI + Settings + Dashboard         Usable. Run alpha test.
Week 5     Onboarding wizard + failure emails          Alpha passes. Invite 10 betas.
Week 6     Stripe billing + usage limits              First paid user possible
Week 7     Analytics + Calendar + polish              Beta feedback → fixes
Week 8     Landing page + Bluesky UI + auto-repost    Open to public
Week 9     Reddit + Indie Hackers + Twitter launch    50+ sign-ups
Week 10    Fix, optimize, Product Hunt launch         100 users ✓

BUILD COST: $0
TIME: 10 weeks solo with AI writing 80% of the code
FIRST REVENUE TARGET: End of Week 6

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Post it. Set it. Flapr does the rest.
  flapr.app

================================================================================
  FLAPR MASTER BUILD DOCUMENT v1.0 FINAL
  Solo builder. Web only. Supabase-first. Test-users-first. $1000 MRR target.
================================================================================
